{"meta":{"title":"Maricus's blog","subtitle":null,"description":null,"author":"Maricus","url":"http://zhangwei94.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-06-02T11:59:09.178Z","updated":"2019-06-02T11:50:19.618Z","comments":false,"path":"/404.html","permalink":"http://zhangwei94.github.io//404.html","excerpt":"","text":""},{"title":"书单","date":"2019-06-02T11:59:09.175Z","updated":"2019-06-02T11:50:19.619Z","comments":false,"path":"books/index.html","permalink":"http://zhangwei94.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-06-02T11:59:09.175Z","updated":"2019-06-02T11:50:19.619Z","comments":false,"path":"about/index.html","permalink":"http://zhangwei94.github.io/about/index.html","excerpt":"","text":"后端开发一枚"},{"title":"项目","date":"2019-06-02T11:59:09.173Z","updated":"2019-06-02T11:50:19.619Z","comments":false,"path":"repository/index.html","permalink":"http://zhangwei94.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-06-02T11:59:09.178Z","updated":"2019-06-02T11:50:19.619Z","comments":false,"path":"categories/index.html","permalink":"http://zhangwei94.github.io/categories/index.html","excerpt":"","text":""},{"title":"链接","date":"2019-06-02T11:59:09.176Z","updated":"2019-06-02T11:50:19.619Z","comments":true,"path":"links/index.html","permalink":"http://zhangwei94.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-02T11:59:09.176Z","updated":"2019-06-02T11:50:19.620Z","comments":false,"path":"tags/index.html","permalink":"http://zhangwei94.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HashMap","slug":"HashMap","date":"2019-06-03T06:15:18.000Z","updated":"2019-06-08T11:06:49.685Z","comments":true,"path":"2019/06/03/HashMap/","link":"","permalink":"http://zhangwei94.github.io/2019/06/03/HashMap/","excerpt":"","text":"前言HashMap是平常开发中用的最多的集合之一，是基于散列表的Map接口的实现。我们首先看一下散列的概念。 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。 相关知识可以查一下维基百科，我们可以看到散列表的两个关键的地方是散列函数和处理冲突的方法 那么在HashMap中是如何实现散列表中的散列函数和处理散列冲突的呢？ HashMap散列策略分析首先HashMap中存储数据是使用数组+链表（长度大于8时转为红黑树）的方式，根据key值计算出数组的下标，如果产生了冲突那么将待插入的元素链接到当前位置链表的末尾，结合上面我们查阅的散列表的知识，可以发现这种解决冲突的方法就是单独链表法. HashMap中就是如何通过key计算出对应的数组下标的呢？这里是通过两个步骤结合来计算的，首先HashMap提供了一个hash()方法如下 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 计算hash值的方法是将key的hash值无符号右移16位然后与其本身进行按位异或计算，目的是将hashCode的高位的特征与低位的特征相结合从而得到分布更加均匀的hash值。通过次方法计算出了分布比较均匀的hash值，那么如何计算出每个hash值对应的下标呢？HashMap中是这样实现的 hash &amp; (length -1) ，其中length就是数组的长度，这个操作其实是与hash%length是一样的，就是对length取模，计算结果就是对应位置的下标。 hash&amp;(length -1) 等于hash%length是有前提条件的，就是length需要为2^n 那么为什么当length是2^n 时就相同呢?现在我们先不考虑HashMap，单独看一下这个公式，当一个数y为2^n时 ,x%y 等于 x&amp;(y-1)。 x对y取模等于x/y的余数，当y为2^n时，x/y等于x&gt;&gt;n,那么余数就是移出的那n位的值。那么如何获取这n位的值呢，我们可以用n位1与x做按位与运算。现在的问题的关键变为了获取n位1，y=2^n那么y-1就是n位1了，所以这时候 x&amp;(y-1)就等于x/y的余数，即：x%y 等于 x&amp;(y-1)。 hash &amp; (length -1) ，当length=2^n 时，hash &amp; (length -1) 就等于 hash%length了 HashMap相关操作分析接下来分析下HashMap中的相关操作 创建HashMap put方法 resize方法 get方法 在开始分析之前我们先看一下HashMap中的常量和参数 1234567891011121314151617181920212223242526/* ---------------- 静态常量 ---------------- *///默认初始化容量static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16//最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//默认负载因子（用来确定数组扩容时机）static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64;/* ---------------- 字段 ---------------- *///table长度总为2^n，在第一次使用时初始化，当size达到扩容阀值时进行扩容。transient Node&lt;K,V&gt;[] table;//entrySettransient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;//Map中包含的key-value个数transient int size;//HashMap结构被修改的次数transient int modCount;//下一次进行resize的阀值（capacity * load factor）int threshold;//负载因子final float loadFactor; HashMap中提供了四个构造方法 1234567891011121314151617181920212223242526//指定容量和负载因子public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;//指定容量public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//使用默认参数public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;//将另外一个map中的全部数据存入public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 其中除了最后一个以另外一个map为参数的构造方法，做了putMapEntries操作，剩下几个都是只对参数进行了赋值，并没有实际初始化数据。 我们首先看一下第一个构造方法，指定了容量和负载因子，判断了参数的合法性后，将loadFactor赋值给参数loadFactor，initialCapacity参数通过tableSizeFor计算出结果赋值给threshold。tableSizeFor方法如下 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 这个方法的作用就是计算出大于输入参数且最近的2的整数次幂的数，我们知道2的整数次幂二进制表示肯定最高位为1后面全是0（比如：1，10，1000），那么当一个不是2的整数次幂的数，想要计算出大于本身且最近的2的整数次幂的数，就将本身其中的0转位1，然后再加1即可。tableSizeFor中的几个无符号右移然后在与本身做或运算的操作就是将其中的0转为1（当输入数为0时特殊，结果还是为0）。无符号右移一位+或运算可以确定最左两位为1，然后无符号右移2位+或运算可以确定最左4位为1，以此类推，直到可以确定int类型32位中有效位全部为1时，然后再加1就可以活得2的整数次幂了。int n = cap - 1是为了在cap本身就是2的整次幂情况，如果直接使用cap计算的话结果就为cap*2了。 这样计算出来的就是大于initialCapacity且最近的2的整数次幂的数，然后将其赋值给了threshold，threshold这个参数本身是存储下次扩容的阀值的，这里将容量参数赋值给了threshold感觉有一些别扭，不过后面在初始化时进行了判断，我个人认为这里使用threshold传递容量参数，而不是定义一个新的initialCapacity参数的目的是减少参数，使得后面初始化的resize方法中的逻辑能相对简洁一些。 第二个构造方法只有一个initialCapacity，负载因子使用DEFAULT_LOAD_FACTOR，第三个构造方法没有参数， initialCapacity和DEFAULT_LOAD_FACTOR全部使用默认值。第四个构造方法使用了默认的负载因子，然后调用了 putMapEntries方法 1234567891011121314151617181920212223242526/** * Implements Map.putAll and Map constructor * * @param m the map * @param evict false when initially constructing this map, else * true (relayed to method afterNodeInsertion). */final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; 首先判断了table是否为null,如果为null标示还没有初始化过table，通过m的大小与负载因子计算threshold， float ft = ((float)s / loadFactor) + 1.0F;最后加1的目的是为了避免将全部元素存入时发生扩容操作。如果table不为null的时候，判断m的大小是否大于扩容的阀值，如果大于的话直接进行扩容操作，这里是提前判断了一下，目的是避免在后面存入元素时产生多次扩容操作。遍历m的元素，循环调用putVal方法将元素存入。resize方法和 putVal，我们和下面的put方法一起分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125;final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; put方法调用了putVal方法，putVal中判断是否需要resize如果需要调用resize方法进行扩容或者初始化。","categories":[{"name":"java源码","slug":"java源码","permalink":"http://zhangwei94.github.io/categories/java源码/"}],"tags":[{"name":"java","slug":"java","permalink":"http://zhangwei94.github.io/tags/java/"},{"name":"源码阅读","slug":"源码阅读","permalink":"http://zhangwei94.github.io/tags/源码阅读/"},{"name":"HashMap","slug":"HashMap","permalink":"http://zhangwei94.github.io/tags/HashMap/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-02T11:50:19.619Z","updated":"2019-06-02T11:50:19.619Z","comments":true,"path":"2019/06/02/hello-world/","link":"","permalink":"http://zhangwei94.github.io/2019/06/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}